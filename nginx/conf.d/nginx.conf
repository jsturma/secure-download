# /etc/openresty/nginx.conf  (ou /usr/local/openresty/nginx/conf/nginx.conf)
worker_processes  auto;
error_log /var/log/nginx/error.log info;
events { worker_connections 1024; }

http {
    lua_package_path "/usr/local/lib/lua/?.lua;/usr/local/openresty/lualib/?.lua;;";

    lua_shared_dict jwks_cache 10m;    # cache JWKS body
    # note: Redis stores sessions, not lua_shared_dict

    init_by_lua_block {
        math.randomseed(os.time())
        
        -- Helper function to resolve symlinks safely
        -- Defined in global scope so it's accessible from all Lua blocks
        _G.resolve_symlink_safe = function(path, allowed_prefix)
            local ffi = require "ffi"
            ffi.cdef[[
                char *realpath(const char *path, char *resolved_path);
            ]]
            
            local buf = ffi.new("char[?]", 4096)
            local result = ffi.C.realpath(path, buf)
            
            if result == nil then
                return nil, "failed to resolve path"
            end
            
            local resolved = ffi.string(buf)
            
            -- Security: Ensure resolved path is still within allowed prefix
            -- Normalize paths by removing trailing slashes for comparison
            local normalized_resolved = resolved:gsub("/+$", "")
            local normalized_prefix = allowed_prefix:gsub("/+$", "")
            
            -- Check that resolved path starts with allowed prefix
            if not (normalized_resolved:sub(1, #normalized_prefix) == normalized_prefix) then
                return nil, "symlink points outside allowed directory"
            end
            
            -- Additional check: resolved path must be an exact match or subdirectory
            local next_char = normalized_resolved:sub(#normalized_prefix + 1, #normalized_prefix + 1)
            if next_char ~= "" and next_char ~= "/" then
                return nil, "symlink traversal detected"
            end
            
            return resolved, nil
        end
    }

    server {
        listen 443 ssl;
        server_name _;

        # TLS certs â€” adapte les chemins
        ssl_certificate     /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;

        # READ-ONLY OPERATIONS: This server only allows GET and HEAD requests
        # All write methods (POST, PUT, DELETE, PATCH) are explicitly denied
        # The /data volume is mounted read-only in docker-compose.yml

        # CONFIG VARIABLES (edit)
        # JWKS URL (Vault) - use Docker service name
        set $vault_jwks_url "http://vault:8200/v1/identity/oidc/.well-known/jwks";
        # Redis connection - use Docker service name
        set $redis_host "redis";
        set $redis_port 6379;
        # Base path where user dirs live
        set $base_data_path "/data";
        # session TTL (seconds) stored in Redis once JWT accepted
        set $session_ttl_seconds 28800;  # 8h
        # maximum token age (optional check on iat), keep 30min default
        set $max_token_age 1800;

        # External entry point: client requests /files/<user>/<path...>
        # READ-ONLY: Only GET and HEAD methods allowed - no file modifications possible
        location ~ ^/files/(?<user>[^/]+)/(?<filepath>.+)$ {
            # Explicitly deny all write methods (POST, PUT, DELETE, PATCH, etc.)
            limit_except GET HEAD { deny all; }

            access_by_lua_block {
                local cjson = require "cjson.safe"
                local http = require "resty.http"
                local jwt = require "resty.jwt"
                local redis = require "resty.redis"
                local str = require "resty.string"

                local vault_jwks_url = ngx.var.vault_jwks_url
                local redis_host = ngx.var.redis_host
                local redis_port = tonumber(ngx.var.redis_port)
                local base_data = ngx.var.base_data_path
                local max_token_age = tonumber(ngx.var.max_token_age)
                local session_ttl = tonumber(ngx.var.session_ttl_seconds)

                local function exit_with(code)
                    return ngx.exit(code)
                end

                -- Helper function to connect to Redis
                local function get_redis()
                    local red = redis:new()
                    red:set_timeout(2000)
                    local ok, err = red:connect(redis_host, redis_port)
                    if not ok then
                        ngx.log(ngx.ERR, "redis connect err: ", err)
                        return nil, err
                    end
                    return red, nil
                end

                -- get cookie sessionid if present
                local session_cookie = ngx.var.cookie_sessionid
                if session_cookie and session_cookie ~= "" then
                    -- validate session in Redis
                    local red, err = get_redis()
                    if not red then
                        return exit_with(500)
                    end
                    local res, err = red:get("sess:" .. session_cookie)
                    if res and res ~= ngx.null then
                        -- session exists; refresh TTL on each request (important for long downloads)
                        red:expire("sess:" .. session_cookie, session_ttl)
                        red:set_keepalive(10000, 100)
                        -- Store session info for internal location
                        ngx.ctx.session_id = session_cookie
                        ngx.ctx.allowed_path = res  -- stored as absolute path
                        -- Redirect to internal location to serve file
                        local req_user = ngx.var.user
                        local req_filepath = ngx.var.filepath
                        return ngx.exec("/internal_files/" .. session_cookie .. "/" .. req_user .. "/" .. req_filepath)
                    end
                    red:set_keepalive(10000, 100)
                    -- otherwise continue to JWT validation
                end

                -- No valid session cookie -> validate JWT
                local auth = ngx.req.get_headers()["Authorization"]
                if not auth then
                    ngx.header["WWW-Authenticate"] = 'Bearer realm="download"'
                    return exit_with(401)
                end
                local m = ngx.re.match(auth, "\\s*[Bb]earer\\s+(.+)")
                if not m then
                    ngx.header["WWW-Authenticate"] = 'Bearer realm="download"'
                    return exit_with(401)
                end
                local token = m[1]

                -- fetch JWKS (cached in lua_shared_dict jwks_cache)
                local jwks_cache = ngx.shared.jwks_cache
                local jwks_body = jwks_cache:get("jwks_body")
                if not jwks_body then
                    local httpc = http.new()
                    httpc:set_timeout(3000)
                    -- Use HTTP (not HTTPS) for internal Docker network, disable SSL verify
                    local res, err = httpc:request_uri(vault_jwks_url, { method = "GET", ssl_verify = false })
                    if not res then
                        ngx.log(ngx.ERR, "failed fetch jwks: ", err)
                        return exit_with(500)
                    end
                    jwks_body = res.body
                    jwks_cache:set("jwks_body", jwks_body, 300) -- cache 5min
                end

                local jwks = cjson.decode(jwks_body)
                if not jwks or not jwks.keys then
                    ngx.log(ngx.ERR, "invalid jwks")
                    return exit_with(500)
                end

                -- Extract kid from token header
                local function b64url_decode(s)
                    s = s:gsub('%-','+'):gsub('_','/')
                    if #s % 4 == 2 then s = s .. '==' elseif #s % 4 == 3 then s = s .. '=' end
                    return ngx.decode_base64(s)
                end
                local header_b64 = token:match("([^%.]+)%.")
                if not header_b64 then
                    return exit_with(401)
                end
                local hdr_json = b64url_decode(header_b64)
                local hdr = cjson.decode(hdr_json)
                if not hdr or not hdr.kid then
                    ngx.log(ngx.ERR, "no kid in token header")
                    return exit_with(401)
                end
                local kid = hdr.kid

                -- Build path to PEM for this kid (generated by jwk2pem.py earlier)
                local pem_path = "/etc/nginx/jwks/" .. kid .. ".pem"
                local pem_file = io.open(pem_path, "rb")
                if not pem_file then
                    ngx.log(ngx.ERR, "pem not found for kid: ", kid, " path:", pem_path)
                    return exit_with(401)
                end
                local pub_pem = pem_file:read("*a")
                pem_file:close()

                -- verify JWT (RS256 expected)
                local verified = jwt:verify(pub_pem, token)
                if not verified or not verified.verified then
                    ngx.log(ngx.WARN, "jwt verify failed: ", (verified and verified.reason) or "unknown")
                    return exit_with(401)
                end

                local payload = verified.payload
                if not payload then
                    ngx.log(ngx.ERR, "no payload")
                    return exit_with(401)
                end

                -- optional: check iat not too old (max_token_age)
                local iat = payload.iat or payload.nbf or 0
                if max_token_age > 0 and (ngx.time() - iat) > max_token_age then
                    ngx.log(ngx.WARN, "token iat too old")
                    return exit_with(401)
                end

                -- check sub equals user and aud equals requested dir (aud optional)
                local sub = payload.sub
                local aud = payload.aud
                local req_user = ngx.var.user
                if not sub or sub ~= req_user then
                    ngx.log(ngx.WARN, "sub mismatch or missing: ", tostring(sub), " != ", req_user)
                    return exit_with(403)
                end
                -- aud may be a string or array; if present, require it equals the requested dir root
                if aud then
                    if type(aud) == "table" then
                        local ok = false
                        for _,v in ipairs(aud) do if v == req_user then ok = true end end
                        if not ok then ngx.log(ngx.WARN,"aud mismatch"); return exit_with(403) end
                    else
                        if aud ~= req_user then ngx.log(ngx.WARN,"aud mismatch"); return exit_with(403) end
                    end
                end

                -- build absolute path, sanitize filepath to prevent traversal
                local filepath = ngx.var.filepath
                if filepath:find("%.%.") then
                    return exit_with(400)
                end
                local abs = base_data .. "/" .. req_user .. "/" .. filepath

                -- check file exists (read-only mode "rb" - binary read only)
                local fh = io.open(abs, "rb")
                if not fh then
                    return exit_with(404)
                end
                fh:close()

                -- Resolve symlinks to ensure we serve the actual file
                -- This also prevents symlink attacks by validating the resolved path
                local user_prefix = base_data .. "/" .. req_user
                local original_path = abs
                local resolved_path, err = resolve_symlink_safe(abs, user_prefix)
                if resolved_path then
                    -- Use resolved path instead of original (symlink resolved)
                    abs = resolved_path
                    ngx.log(ngx.INFO, "Symlink resolved: original=", original_path, " resolved=", resolved_path)
                elseif err == "symlink points outside allowed directory" or err == "symlink traversal detected" then
                    ngx.log(ngx.WARN, "Symlink attack prevented: ", original_path, " error: ", err)
                    return exit_with(403)
                end
                -- If err is "failed to resolve path", continue with original path
                -- (might not be a symlink or might be a regular file)

                -- create session stored in Redis
                local red, err = get_redis()
                if not red then
                    return exit_with(500)
                end

                -- generate random session id
                local resty_random = require "resty.random"
                local rand = resty_random.bytes(16, true)
                local sid = ngx.encode_base64(rand):gsub("[+/=]", "")
                local payload_to_store = abs
                local res, err = red:setex("sess:" .. sid, session_ttl, payload_to_store)
                if not res then
                    ngx.log(ngx.ERR, "redis setex err: ", err)
                    red:set_keepalive(10000, 100)
                    return exit_with(500)
                end
                red:set_keepalive(10000, 100)

                -- set cookie (session persists even after JWT expires)
                ngx.header["Set-Cookie"] = "sessionid=" .. sid .. "; Path=/; HttpOnly; Secure; SameSite=Strict"

                -- put allowed path into ctx so internal location can use it
                ngx.ctx.allowed_path = abs
                ngx.ctx.session_id = sid

                -- redirect to internal handler which will serve file using session
                return ngx.exec("/internal_files/" .. sid .. "/" .. req_user .. "/" .. filepath)
            }  -- end access_by_lua_block
        }

        # Internal location that serves the file using the session validated with Redis
        # This allows downloads to continue even after JWT expires, as long as session is valid
        location ~ ^/internal_files/(?<sid>[^/]+)/(?<user>[^/]+)/(?<filepath>.+)$ {
            internal;
            # validate session via redis and serve the exact allowed file
            content_by_lua_block {
                local redis = require "resty.redis"
                local sid = ngx.var.sid
                local user = ngx.var.user
                local filepath = ngx.var.filepath
                
                if not sid or sid == "" then 
                    return ngx.exit(403) 
                end

                -- Connect to Redis and validate session
                local red = redis:new()
                red:set_timeout(2000)
                local redis_host = ngx.var.redis_host
                local redis_port = tonumber(ngx.var.redis_port)
                local ok, err = red:connect(redis_host, redis_port)
                if not ok then
                    ngx.log(ngx.ERR,"redis connect err: ", err)
                    return ngx.exit(500)
                end

                -- Get allowed path from Redis session
                local allowed = red:get("sess:" .. sid)
                if not allowed or allowed == ngx.null then
                    red:set_keepalive(10000, 100)
                    return ngx.exit(403)
                end

                -- Refresh session TTL on each request (important for long/resumable downloads)
                local session_ttl = tonumber(ngx.var.session_ttl_seconds)
                red:expire("sess:" .. sid, session_ttl)
                red:set_keepalive(10000, 100)

                -- Security: ensure requested file matches the session's allowed path
                local base_data = ngx.var.base_data_path
                local prefix = base_data .. "/" .. user .. "/"
                
                -- Check that session's allowed path starts with expected prefix
                if not (allowed:sub(1, #prefix) == prefix) then
                    ngx.log(ngx.WARN, "session path mismatch: ", allowed, " vs ", prefix)
                    return ngx.exit(403)
                end

                -- Compute absolute target path to serve
                local target = prefix .. filepath
                
                -- Prevent directory traversal
                if target:find("%.%.") then 
                    return ngx.exit(400) 
                end
                
                -- Ensure target is under the allowed directory (not just prefix)
                -- Extract directory from allowed path
                local allowed_dir = allowed:match("^(.+)/[^/]+$") or base_data .. "/" .. user
                if not (target:sub(1, #allowed_dir) == allowed_dir) then
                    -- Allow serving files in subdirectories under the user's directory
                    -- but ensure they're under the user's prefix
                    if not (target:sub(1, #prefix) == prefix) then
                        ngx.log(ngx.WARN, "path traversal attempt: ", target)
                        return ngx.exit(403)
                    end
                end

                -- Resolve symlinks to ensure we serve the actual file
                -- This also prevents symlink attacks by validating the resolved path
                local original_target = target
                local resolved_target, err = resolve_symlink_safe(target, prefix)
                if resolved_target then
                    -- Use resolved path instead of original (symlink resolved)
                    target = resolved_target
                    ngx.log(ngx.INFO, "Symlink resolved: original=", original_target, " resolved=", resolved_target)
                    
                    -- Update allowed path in Redis to reflect resolved symlink
                    -- This ensures subsequent requests use the resolved path
                    red:set("sess:" .. sid, resolved_target)
                    red:expire("sess:" .. sid, session_ttl)
                elseif err == "symlink points outside allowed directory" or err == "symlink traversal detected" then
                    ngx.log(ngx.WARN, "Symlink attack prevented: ", original_target, " error: ", err)
                    return ngx.exit(403)
                end
                -- If err is "failed to resolve path", continue with original path
                -- (might not be a symlink or might be a regular file)

                -- Check file exists (read-only mode "rb" - binary read)
                local fh = io.open(target, "rb")
                if not fh then 
                    return ngx.exit(404) 
                end
                fh:close()
                
                -- Compute relative path from resolved target for serving
                -- Extract the relative path from prefix
                local relative_path = target:sub(#prefix + 1)
                if relative_path:sub(1, 1) == "/" then
                    relative_path = relative_path:sub(2)
                end

                -- Serve file via internal location with alias (use resolved path)
                ngx.exec("/serve_file_internal/" .. user .. "/" .. relative_path)
            }
        }

        # actual internal static file serving location (alias)
        # READ-ONLY: Internal location for serving files - no write operations possible
        # SYMLINK SUPPORT: Follows symlinks to serve actual files (resolved and validated by Lua)
        location ~ ^/serve_file_internal/(?<user>[^/]+)/(?<filepath>.+)$ {
            internal;  # Can only be accessed via internal redirects, not external requests
            alias /data/;    # root. The rewrite above composes full path: /data/<user>/<filepath>
            disable_symlinks off;  # Follow symlinks (already validated by Lua to prevent attacks)
            # Use sendfile for performance (read-only file transfer)
            sendfile on;
            # Turn off client_body_buffering - we don't accept uploads (read-only)
            client_body_buffer_size 0;
            client_max_body_size 0;
            # Enable range requests for resumable downloads
            add_header Accept-Ranges bytes;
            # Ensure only GET/HEAD methods (double-check, though internal shouldn't receive writes)
            limit_except GET HEAD { deny all; }
        }

        # Default deny all other locations - this is a read-only download service
        location / {
            deny all;
            return 404;
        }

    }  -- server
} -- http
